<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 模型全屏展示</title>
    <!-- 使用备用 CDN 方式导入 Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background-color: #f0f0f0;
            overflow: hidden;
        }
        #model-container {
            width: 100vw;
            height: 100vh;
            background-color: #f0f0f0;
        }
        
        /* 加载动画样式 */
        #loading-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.8s ease-out, visibility 0.8s;
        }
        
        #loading-container.hidden {
            opacity: 0;
            visibility: hidden;
        }
        
        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid #ccc;
            border-top: 4px solid #4CAF50;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        .loading-text {
            color: #333;
            font-family: Arial, sans-serif;
            font-size: 18px;
            text-align: center;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* FPS显示样式 */
        #fps-counter {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            font-family: Arial, sans-serif;
            font-size: 14px;
            border-radius: 4px;
            z-index: 999;
        }
        
        /* 缩放控制按钮样式 - 毛玻璃效果 */
        .zoom-controls {
            position: fixed;
            right: 20px;
            bottom: 60px; /* 向上移动了一些距离 */
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 999;
        }
        
        .zoom-btn {
            width: 40px;
            height: 40px;
            background-color: rgba(0, 0, 0, 0.8); /* 黑色背景 */
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .zoom-btn:hover {
            background-color: rgba(0, 0, 0, 1);
            transform: scale(1.1);
        }
        
        .zoom-btn:active {
            transform: scale(0.95);
        }
        
        /* 加载提示样式 */
        .loading-tip {
            position: fixed;
            top: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1000;
            opacity: 1;
            transition: opacity 0.5s ease;
        }
        
        .loading-tip.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .zoom-btn:hover {
            background-color: rgba(255, 255, 255, 0.25);
            transform: scale(1.05);
        }
        
        .zoom-btn:active {
            transform: scale(0.95);
        }
        
        /* 进度条样式 */
        .progress-container {
            width: 80%;
            max-width: 600px;
            height: 20px;
            background-color: #ddd;
            border-radius: 10px;
            margin: 15px 0;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background-color: #4CAF50;
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }
        
        /* 加载详情信息 */
        .loading-details {
            color: #555;
            font-family: Arial, sans-serif;
            font-size: 14px;
            text-align: center;
            margin-top: 10px;
            max-width: 80%;
        }
        
        /* 加载日志区域 */
        .loading-logs {
            position: fixed;
            bottom: 10px;
            left: 10px;
            right: 10px;
            height: 150px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            overflow-y: auto;
            z-index: 997;
            display: none;
        }
        
        /* 显示日志按钮 */
        #show-logs-btn {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background-color: rgba(76, 175, 80, 0.9);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            z-index: 998;
        }
        
        #show-logs-btn:hover {
            background-color: rgba(76, 175, 80, 1);
        }
    </style>
</head>
<body>
    <div id="model-container">
    </div>
    
    <!-- 加载动画容器 -->
    <div id="loading-container">
        <div class="loading-spinner"></div>
        <div class="loading-text">正在准备加载...</div>
        <div class="progress-container">
            <div class="progress-bar"></div>
        </div>
        <div class="loading-details">初始化资源...</div>
    </div>
    
    <!-- 加载日志按钮 -->
    <button id="show-logs-btn">显示加载日志</button>
    <div id="loading-logs" class="loading-logs"></div>
    
    <!-- FPS显示容器 -->
    <!-- FPS显示 -->
    <div id="fps-counter">FPS: 0</div>
    
    <!-- 加载提示 -->
    <div id="loading-tip" class="loading-tip">
    提示：使用鼠标左键控制视角X轴移动，右下角按钮放大缩小模型
    </div>
    
    <!-- 缩放控制按钮 -->
    <div class="zoom-controls">
        <button id="zoom-in-btn" class="zoom-btn">+</button>
        <button id="zoom-out-btn" class="zoom-btn">-</button>
    </div>
    <script type="module">
        // 使用标准 ES Module 导入 Three.js 和相关组件
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { MeshoptDecoder } from 'three/addons/libs/meshopt_decoder.module.js';
        
        // 初始化变量
        let scene, camera, renderer, controls;
        let loadedModels = [];
        let modelFiles = [];
        let fpsCounter = null;
        let frameCount = 0;
        let lastFpsUpdate = 0;
        let chunkLoader = null;
        let modelChunks = {}; // 存储模型块
        let loadingManager = null;
        let loadedChunksCount = 0; // 已加载的块数量
        let totalChunksCount = 0; // 总块数量
        let isLoadingChunks = false; // 是否正在加载块
        let chunkLoadingQueue = []; // 块加载队列
        let maxConcurrentChunkLoads = 2; // 最大并发加载数
        let failedChunks = []; // 存储加载失败的块
        let maxRetries = 3; // 每个块的最大重试次数
        
        // 资源加载跟踪变量
        let totalBytesLoaded = 0; // 已加载总字节数
        let totalBytesToLoad = 0; // 预计总字节数
        let startTime = 0; // 开始加载时间
        let averageLoadSpeed = 0; // 平均加载速度 (KB/s)
        let lastLoadedTime = 0; // 最后加载时间点
        let lastLoadedBytes = 0; // 最后加载字节数
        let isLoadingComplete = false; // 加载是否完成
        
        // 缓存机制
        const resourceCache = new Map(); // 资源缓存
        const CACHE_ENABLED = true; // 是否启用缓存
        const CACHE_EXPIRE_TIME = 60 * 60 * 1000; // 缓存过期时间 (1小时)
        
        // 初始化Three.js场景
        function initThreeJS() {
            // 创建场景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0); // 设置为灰色背景
            
            // 创建相机
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            
            // 创建渲染器
            renderer = new THREE.WebGLRenderer({ 
                antialias: false,
                powerPreference: 'high-performance'
            });
            
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('model-container').appendChild(renderer.domElement);
            
            // 获取FPS计数器元素
            fpsCounter = document.getElementById('fps-counter');
            
            // 添加光源
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            // 添加顶部灯光
            const topLight = new THREE.DirectionalLight(0xffffff, 0.8);
            topLight.position.set(0, 10, 0); // 放置在顶部位置
            scene.add(topLight);
            
            // 添加轨道控制器 - 按照用户要求配置交互控制
            controls = new OrbitControls(camera, renderer.domElement);
            
            // 基础配置
            controls.enableDamping = true; // 启用阻尼效果，使操作更平滑
            controls.dampingFactor = 0.05; // 设置阻尼系数
            
            // 配置鼠标按钮 - 按照用户要求配置交互控制
            controls.mouseButtons = {
                LEFT: THREE.MOUSE.PAN,     // 左键用于平移（控制x轴移动）
                MIDDLE: THREE.MOUSE.ROTATE, // 鼠标中键用于旋转（同时控制Yaw和Pitch）
                RIGHT: THREE.MOUSE.NONE     // 禁用右键功能
            };
            
            // 配置触摸控制
            controls.touches = {
                ONE: THREE.TOUCH.NONE,      // 禁用单指操作
                TWO: THREE.TOUCH.NONE       // 禁用双指操作
            };
            
            // 缩放视图配置 - 滚轮控制放大缩小
            controls.enableZoom = true;     // 启用缩放
            controls.zoomSpeed = 1.0;       // 设置缩放速度
            controls.enableMouseZoom = true; // 启用鼠标滚轮缩放
            
            // 旋转视图配置 - 按下滚轮控制Yaw和Pitch
            controls.enableRotate = true;   // 启用旋转
            controls.rotateSpeed = 1.5;     // 设置旋转速度
            
            // 禁用平移功能
            controls.enablePan = true;     // 启用平移功能（因为我们将左键设置为平移控制）
            controls.panSpeed = 1.0;       // 设置平移速度
            
            // 禁用键盘控制
            controls.enableKeys = false;    // 禁用键盘控制
            
            // 移除所有旋转限制，确保Yaw和Pitch可以自由旋转
            controls.minPolarAngle = 0;     // 允许向下旋转到水平
            controls.maxPolarAngle = Math.PI; // 允许向上旋转到完全倒置
            controls.minAzimuthAngle = -Infinity; // 允许无限向左旋转
            controls.maxAzimuthAngle = Infinity;  // 允许无限向右旋转
            
            // 缩放距离限制
            controls.minDistance = 0.1;     // 最小缩放距离
            controls.maxDistance = 1000;    // 最大缩放距离
            
            // 设置窗口大小变化监听
            window.addEventListener('resize', onWindowResize);
            
            // 初始化加载管理器
            loadingManager = new THREE.LoadingManager();
            loadingManager.onProgress = function(url, itemsLoaded, itemsTotal) {
                const percent = Math.round((itemsLoaded / itemsTotal) * 100);
                const loadingText = document.querySelector('.loading-text');
                if (loadingText) {
                    loadingText.textContent = `正在加载模型块: ${percent}%`;
                }
            };
            
            // 开始渲染循环
            animate();
        }
        
        // 窗口大小变化时更新相机和渲染器
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // 渲染循环 - 添加帧率优化
        let lastFrameTime = 0;
        const MAX_FPS = 60;
        const MIN_FRAME_TIME = 1000 / MAX_FPS;
        
        function animate(timestamp) {
            requestAnimationFrame(animate);
            
            // 限制帧率以提高性能
            if (timestamp - lastFrameTime < MIN_FRAME_TIME) {
                return;
            }
            
            lastFrameTime = timestamp;
            
            // 更新控制器
            controls.update();
            
            // 计算和更新FPS
            if (fpsCounter) {
                frameCount++;
                if (timestamp - lastFpsUpdate >= 1000) { // 每秒更新一次
                    const fps = Math.round((frameCount * 1000) / (timestamp - lastFpsUpdate));
                    fpsCounter.textContent = `FPS: ${fps}`;
                    frameCount = 0;
                    lastFpsUpdate = timestamp;
                }
            }
            
            // 渲染场景
            renderer.render(scene, camera);
        }
        
        // 初始化分块加载器
        function initChunkLoader() {
            // 创建GLTFLoader
            const loader = new GLTFLoader(loadingManager);
            
            // 创建和配置DracoLoader用于压缩模型
            const dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath('https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/');
            loader.setDRACOLoader(dracoLoader);
            
            // 配置meshopt解码器
            loader.setMeshoptDecoder(MeshoptDecoder);
            
            return loader;
        }
        
        // 分块加载模型
        function loadModelInChunks(modelName) {
            chunkLoader = initChunkLoader();
            
            // 获取加载容器引用
            const loadingContainer = document.getElementById('loading-container');
            const loadingText = document.querySelector('.loading-text');
            
            function hideLoadingAnimation() {
                if (loadingContainer) {
                    console.log('隐藏加载动画');
                    loadingContainer.classList.add('hidden');
                }
            }
            
            function showError(message) {
                if (loadingText) {
                    loadingText.textContent = message;
                    loadingText.style.color = '#ff0000'; // 红色错误信息
                }
                console.error('模型加载错误:', message);
                
                // 5秒后隐藏加载动画并显示替代几何体
                setTimeout(() => {
                    hideLoadingAnimation();
                    createFallbackGeometry();
                }, 3000);
            }
            
            // 检查文件大小（通过HEAD请求）
            function checkFileSize(path) {
                return new Promise((resolve, reject) => {
                    const xhr = new XMLHttpRequest();
                    xhr.open('HEAD', path, true);
                    xhr.onreadystatechange = function() {
                        if (xhr.readyState === 4) {
                            if (xhr.status === 200) {
                                const fileSize = parseInt(xhr.getResponseHeader('Content-Length')) || 0;
                                resolve(fileSize);
                            } else {
                                reject(new Error(`无法获取文件大小，状态码: ${xhr.status}`));
                            }
                        }
                    };
                    xhr.onerror = function() {
                        reject(new Error('网络错误，无法获取文件大小'));
                    };
                    xhr.send();
                });
            }
            
            // 增强的路径处理逻辑 - 适应不同环境
            const possiblePaths = [
                modelName,                           // 直接文件名
                '/' + modelName,                      // 根目录
                './' + modelName,                     // 当前目录
                './模型/' + modelName,                 // 模型子目录
                '模型/' + modelName                    // 另一种模型目录格式
            ];
            
            async function startLoading() {
                try {
                    // 尝试第一个路径（主要路径）
                    const mainPath = possiblePaths[0];
                    
                    // 先检查文件大小
                    const fileSize = await checkFileSize(mainPath);
                    const sizeInGB = (fileSize / (1024 * 1024 * 1024)).toFixed(2);
                    
                    // 更新加载文本
                    if (loadingText) {
                        loadingText.textContent = `准备加载大型模型(${sizeInGB}GB)...`;
                    }
                    
                    // 配置分块加载选项
                    const chunkOptions = {
                        // 使用流式加载
                        streaming: true,
                        // 优先级设置（基于相机距离）
                        prioritizeLoadedChunks: true,
                        // 设置最大加载块数
                        maxConcurrentChunks: 3,
                        // 内存优化
                        useBrowserCache: true
                    };
                    
                    console.log('开始分块加载模型:', mainPath);
                    
                    // 尝试使用流式加载模式
                    chunkLoader.load(
                        mainPath,
                        function(gltf) {
                            console.log('模型加载成功:', mainPath);
                            const model = gltf.scene;
                            loadedModels.push(model);
                            
                            // 优化模型处理 - 简化光照计算
                            model.traverse(function(child) {
                                if (child.isMesh) {
                                    child.castShadow = false;
                                    child.receiveShadow = false;
                                    // 减少材质复杂度
                                    if (child.material) {
                                        child.material.envMapIntensity = 0.5;
                                    }
                                }
                            });
                            
                            // 让模型横向显示 - 旋转-90度（修正方向）
                            model.rotation.x = -Math.PI / 2; // 绕X轴旋转-90度
                            
                            // 优化模型 - 合并相同材质的几何体
                            optimizeModelGeometry(model);
                            
                            scene.add(model);
                            
                            // 调整相机
                            adjustCamera(model);
                            
                            // 添加渐进式加载更新
                            startProgressiveLoadingUpdate(model);
                            
                            // 隐藏加载动画
                            setTimeout(hideLoadingAnimation, 1000);
                        },
                        function(xhr) {
                            // 显示加载进度
                            if (xhr.lengthComputable && loadingText) {
                                const percent = Math.round((xhr.loaded / xhr.total) * 100);
                                loadingText.textContent = `正在加载模型: ${percent}% - 大型模型加载可能需要较长时间`;
                            }
                        },
                        function(error) {
                            console.error(`模型加载失败:`, error);
                            
                            // 特殊处理内存不足错误
                            if (error.message && (error.message.includes('out of memory') || error.message.includes('内存不足'))) {
                                showError('浏览器内存不足，正在尝试优化加载方式...');
                                // 尝试使用更低内存的加载方式
                                setTimeout(() => {
                                    tryLowMemoryLoading(mainPath);
                                }, 2000);
                                return;
                            }
                            
                            showError('模型加载失败，请确保模型文件格式正确且可用。');
                        }
                    );
                    
                } catch (error) {
                    console.error('分块加载初始化失败:', error);
                    showError('无法开始分块加载，请检查网络连接或文件权限。');
                }
            }
            
            // 低内存加载模式
            function tryLowMemoryLoading(modelPath) {
                console.log('尝试低内存加载模式');
                const loadingText = document.querySelector('.loading-text');
                if (loadingText) {
                    loadingText.textContent = '正在使用低内存模式加载...';
                }
                
                // 创建一个新的加载器，禁用一些高内存功能
                const lowMemoryLoader = new GLTFLoader(loadingManager);
                
                lowMemoryLoader.load(
                    modelPath,
                    function(gltf) {
                        console.log('低内存模式加载成功');
                        const model = gltf.scene;
                        
                        // 激进的内存优化
                        optimizeModelForLowMemory(model);
                        
                        scene.add(model);
                        adjustCamera(model);
                        hideLoadingAnimation();
                    },
                    undefined,
                    function(error) {
                        console.error('低内存模式加载失败:', error);
                        showError('无法加载模型，请尝试使用更小的模型文件或更强的设备。');
                    }
                );
            }
            
            // 开始加载
            startLoading();
        }
        
        // 优化模型几何体
        function optimizeModelGeometry(model) {
            // 这里可以实现几何体合并等优化
            // 对于非常大的模型，我们不进行合并以保持分块加载的优势
            console.log('模型几何体优化完成');
        }
        
        // 为低内存设备优化模型
        function optimizeModelForLowMemory(model) {
            model.traverse(function(child) {
                if (child.isMesh) {
                    // 简化几何体 - 如果有大量顶点
                    if (child.geometry && child.geometry.attributes.position.count > 10000) {
                        // 这里可以添加几何体简化逻辑
                        console.log('简化几何体顶点数');
                    }
                    
                    // 降低材质质量
                    if (child.material) {
                        child.material.roughness = 1; // 减少镜面反射计算
                        child.material.metalness = 0; // 减少金属效果计算
                        if (child.material.map) {
                            child.material.map.minFilter = THREE.LinearFilter; // 降低纹理过滤质量
                            child.material.map.magFilter = THREE.LinearFilter;
                        }
                    }
                }
            });
            console.log('低内存模式模型优化完成');
        }
        
        // 启动渐进式加载更新
        function startProgressiveLoadingUpdate(model) {
            // 在这里可以实现基于相机移动的动态加载/卸载模型块
            console.log('启动渐进式加载更新系统');
            
            // 添加定期检查相机位置的功能
            let lastCameraPosition = new THREE.Vector3();
            
            function checkCameraMovement() {
                if (!camera || !model) return;
                
                // 只有当相机移动超过阈值时才进行更新
                if (camera.position.distanceTo(lastCameraPosition) > 1.0) {
                    lastCameraPosition.copy(camera.position);
                    // 这里可以实现基于相机距离的LOD（细节级别）管理
                    updateModelLOD(model);
                }
                
                // 继续检查
                requestAnimationFrame(checkCameraMovement);
            }
            
            // 开始检查相机移动
            setTimeout(checkCameraMovement, 1000);
        }
        
        // 更新模型LOD（细节级别）
        function updateModelLOD(model) {
            // 简单的LOD实现 - 基于相机距离调整模型复杂度
            const distance = camera.position.distanceTo(model.position);
            
            // 根据距离调整模型质量
            if (distance > 50) {
                // 远距离 - 最低质量
                setModelQuality(model, 0.3);
            } else if (distance > 20) {
                // 中等距离 - 中等质量
                setModelQuality(model, 0.7);
            } else {
                // 近距离 - 高质量
                setModelQuality(model, 1.0);
            }
        }
        
        // 设置模型质量
        function setModelQuality(model, quality) {
            // 简单实现 - 启用/禁用某些细节部分
            // 在实际应用中，可以实现更复杂的LOD系统
            model.traverse(function(child) {
                if (child.isMesh && child.userData && child.userData.detailLevel) {
                    // 只显示质量级别高于当前设置的细节
                    child.visible = child.userData.detailLevel <= quality;
                }
            });
        }
        
        // 创建替代几何体
        function createFallbackGeometry() {
            console.log('创建替代几何体');
            
            // 创建一个简单的立方体
            const geometry = new THREE.BoxGeometry(2, 2, 2);
            const material = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                wireframe: true
            });
            
            const cube = new THREE.Mesh(geometry, material);
            scene.add(cube);
            loadedModels.push(cube);
            
            // 调整相机
            adjustCamera(cube);
            
            // 隐藏加载动画
            setTimeout(() => {
                document.getElementById('loading-container').classList.add('hidden');
            }, 500);
        }
        
        // 调整相机以适合模型
        function adjustCamera(model) {
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());
            
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
            cameraZ *= 1.5;
            
            camera.position.set(center.x, center.y, cameraZ);
            controls.target.copy(center);
            controls.update();
        }
        
        // 扫描模型文件
        function scanModelFiles() {
            // 首先检查是否存在mx2文件夹中的分块模型文件
            // 注意：由于浏览器安全限制，我们不能直接扫描文件系统
            // 因此我们需要先尝试列出mx2文件夹中的模型块数量
            checkForChunksDirectory();
        }
        
        // 检查是否存在分块目录并尝试加载分块模型
        function checkForChunksDirectory() {
            // 我们尝试访问mx2目录中的第一个文件来验证目录存在
            const testChunkUrl = 'mx2/______0000000.glb';
            
            const xhr = new XMLHttpRequest();
            xhr.open('HEAD', testChunkUrl, true);
            xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                    if (xhr.status === 200) {
                        console.log('检测到mx2分块模型目录');
                        // 尝试加载预分块的模型
                        loadPreChunkedModel();
                    } else {
                        console.log('未检测到mx2分块模型目录，尝试加载单一模型文件');
                        modelFiles.push('merged.glb');
                    }
                }
            };
            xhr.onerror = function() {
                console.log('检测分块目录失败，尝试加载单一模型文件');
                modelFiles.push('merged.glb');
            };
            xhr.send();
        }
        
        // 加载预分块的模型
        function loadPreChunkedModel() {
            console.log('准备加载预分块的模型');
            // 估计mx2目录中的模型块数量
            // 通过观察目录结构，我们知道至少有40个块
            totalChunksCount = 40;
            
            // 创建一个代表整个模型的空容器
            const fullModel = new THREE.Group();
            fullModel.name = 'FullModel';
            loadedModels.push(fullModel);
            scene.add(fullModel);
            
            // 启动分块加载过程
            startChunkLoading();
        }
        
        // 初始化分块加载
        function startChunkLoading() {
            console.log('开始分块加载过程');
            const loadingText = document.querySelector('.loading-text');
            
            if (loadingText) {
                loadingText.textContent = '准备加载分块模型...';
            }
            
            // 初始化分块加载器
            chunkLoader = initChunkLoader();
            
            // 构建块加载队列 - 按照块索引顺序加载
            for (let i = 0; i < totalChunksCount; i++) {
                const chunkIndex = String(i).padStart(7, '0');
                const chunkUrl = `mx2/______${chunkIndex}.glb`;
                
                // 添加到加载队列
                chunkLoadingQueue.push({
                    url: chunkUrl,
                    index: i,
                    priority: calculateChunkPriority(i) // 计算块的加载优先级
                });
            }
            
            // 按优先级排序加载队列
            chunkLoadingQueue.sort((a, b) => a.priority - b.priority);
            
            // 开始加载第一批块
            loadNextChunks();
        }
        
        // 计算块的加载优先级（简单实现）
        function calculateChunkPriority(chunkIndex) {
            // 中心区域的块优先加载
            // 假设中间索引（约20）是模型的中心部分
            const centerIndex = totalChunksCount / 2;
            const distanceFromCenter = Math.abs(chunkIndex - centerIndex);
            
            // 距离中心越近，优先级越高（数值越小）
            return distanceFromCenter;
        }
        
        // 加载下一批分块
        function loadNextChunks() {
            // 检查是否还有块需要加载
            if (chunkLoadingQueue.length === 0) {
                console.log('所有分块模型加载完成');
                onAllChunksLoaded();
                return;
            }
            
            // 计算当前正在加载的块数量
            const activeLoads = Object.values(modelChunks).filter(chunk => chunk.loading).length;
            
            // 如果当前加载的块数量少于最大并发数，则加载更多块
            const chunksToLoad = maxConcurrentChunkLoads - activeLoads;
            
            for (let i = 0; i < chunksToLoad && chunkLoadingQueue.length > 0; i++) {
                const nextChunk = chunkLoadingQueue.shift();
                loadChunk(nextChunk);
            }
        }
        
        // 格式化文件大小
        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            else if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
            else return (bytes / 1048576).toFixed(1) + ' MB';
        }
        
        // 计算加载速度
        function calculateLoadSpeed(bytesLoaded) {
            const currentTime = Date.now();
            const timeDiff = (currentTime - lastLoadedTime) / 1000; // 转换为秒
            const bytesDiff = bytesLoaded - lastLoadedBytes;
            
            if (timeDiff > 0) {
                const speed = bytesDiff / timeDiff; // B/s
                averageLoadSpeed = averageLoadSpeed * 0.7 + speed * 0.3; // 平滑处理
                
                lastLoadedTime = currentTime;
                lastLoadedBytes = bytesLoaded;
            }
            
            return averageLoadSpeed;
        }
        
        // 计算预计剩余时间
        function calculateRemainingTime() {
            if (totalBytesLoaded === 0 || totalBytesToLoad === 0) return '未知';
            
            const remainingBytes = totalBytesToLoad - totalBytesLoaded;
            const speed = calculateLoadSpeed(totalBytesLoaded);
            
            if (speed === 0) return '未知';
            
            const remainingSeconds = Math.round(remainingBytes / speed);
            
            if (remainingSeconds < 60) {
                return `${remainingSeconds}秒`;
            } else {
                const minutes = Math.floor(remainingSeconds / 60);
                const seconds = remainingSeconds % 60;
                return `${minutes}分${seconds}秒`;
            }
        }
        
        // 加载单个分块
        function loadChunk(chunkInfo) {
            const { url, index, retries = 0 } = chunkInfo;
            const loadingText = document.querySelector('.loading-text');
            const loadingDetails = document.querySelector('.loading-details');
            
            // 标记此块为正在加载
            modelChunks[index] = {
                loading: true,
                loaded: false,
                object: null,
                retries: retries
            };
            
            const logMsg = `开始加载模型块 ${index}/${totalChunksCount}: ${url}${retries > 0 ? ` (重试 ${retries}/${maxRetries})` : ''}`;
            console.log(logMsg);
            addLoadingLog(logMsg);
            
            // 更新加载文本
            updateLoadingProgress();
            
            if (loadingDetails) {
                loadingDetails.textContent = `正在加载块 ${index}/${totalChunksCount}${retries > 0 ? ` (重试 ${retries}/${maxRetries})` : ''}`;
            }
            
            // 为了防止并发请求过多导致的问题，添加小延迟
            setTimeout(() => {
                // 创建带有缓存的加载函数
                function loadWithCache(url, onLoad, onProgress, onError) {
                    if (CACHE_ENABLED && resourceCache.has(url)) {
                        const cachedItem = resourceCache.get(url);
                        // 检查缓存是否过期
                        if (Date.now() - cachedItem.timestamp < CACHE_EXPIRE_TIME) {
                            addLoadingLog(`从缓存加载块 ${index}`);
                            onLoad(cachedItem.data);
                            return;
                        }
                    }
                    
                    // 常规加载
                    chunkLoader.load(
                        url,
                        function(data) {
                            // 存入缓存
                            if (CACHE_ENABLED) {
                                resourceCache.set(url, {
                                    data: data,
                                    timestamp: Date.now()
                                });
                            }
                            onLoad(data);
                        },
                        onProgress,
                        onError
                    );
                }
                
                // 加载块
                loadWithCache(
                    url,
                    function(gltf) {
                        const successMsg = `成功加载模型块 ${index}/${totalChunksCount}: ${url}`;
                        console.log(successMsg);
                        addLoadingLog(successMsg);
                        
                        const chunkModel = gltf.scene;
                        
                        // 优化块模型
                        optimizeChunkModel(chunkModel, index);
                        
                        // 存储加载的块
                        modelChunks[index] = {
                            loading: false,
                            loaded: true,
                            object: chunkModel
                        };
                        
                        // 将块添加到完整模型中
                        const fullModel = loadedModels.find(model => model.name === 'FullModel');
                        if (fullModel) {
                            fullModel.add(chunkModel);
                        }
                        
                        // 增加已加载块计数
                        loadedChunksCount++;
                        
                        // 更新加载进度
                        updateLoadingProgress();
                        
                        // 加载下一批块
                        loadNextChunks();
                        
                    },
                    function(xhr) {
                        // 添加单个块的加载进度
                        if (xhr.lengthComputable) {
                            const percent = Math.round((xhr.loaded / xhr.total) * 100);
                            const currentChunkBytesLoaded = xhr.loaded;
                            const currentChunkBytesTotal = xhr.total;
                            
                            // 更新总字节数（如果是新块的首次加载）
                            if (!modelChunks[index].totalBytes) {
                                modelChunks[index].totalBytes = currentChunkBytesTotal;
                                totalBytesToLoad += currentChunkBytesTotal;
                            }
                            
                            // 计算当前已加载的总字节数
                            const previousLoadedBytes = modelChunks[index].loadedBytes || 0;
                            modelChunks[index].loadedBytes = currentChunkBytesLoaded;
                            
                            // 只在新数据到达时更新总字节计数
                            if (currentChunkBytesLoaded > previousLoadedBytes) {
                                totalBytesLoaded += (currentChunkBytesLoaded - previousLoadedBytes);
                            }
                            
                            // 更新详细进度信息
                            const speed = calculateLoadSpeed(totalBytesLoaded);
                            const remainingTime = calculateRemainingTime();
                            
                            if (loadingDetails) {
                                loadingDetails.textContent = `块 ${index} 加载中: ${percent}% | 速度: ${formatFileSize(speed)}/s | 预计剩余: ${remainingTime}`;
                            }
                        }
                    },
                    function(error) {
                        const errorMsg = `加载模型块 ${index} 失败: ${error.message}`;
                        console.error(errorMsg);
                        addLoadingLog(errorMsg, true);
                        
                        // 如果重试次数未达到上限，则添加到失败列表以便重试
                        if (retries < maxRetries) {
                            const retryMsg = `将在延迟后重试加载模型块 ${index}`;
                            console.log(retryMsg);
                            addLoadingLog(retryMsg);
                            // 添加到失败列表，稍后重试
                            failedChunks.push({
                                url: url,
                                index: index,
                                retries: retries + 1
                            });
                        } else {
                            const maxRetryMsg = `模型块 ${index} 达到最大重试次数，不再重试`;
                            console.error(maxRetryMsg);
                            addLoadingLog(maxRetryMsg, true);
                            // 标记此块为加载失败
                            modelChunks[index] = {
                                loading: false,
                                loaded: false,
                                error: error
                            };
                        }
                        
                        // 继续加载下一批块
                        loadNextChunks();
                    }
                );
            }, index * 100); // 为不同的块添加不同的延迟，减少并发请求
        }
        
        // 优化块模型
        function optimizeChunkModel(model, chunkIndex) {
            // 设置块模型的属性
            model.name = `ModelChunk_${chunkIndex}`;
            
            // 简化光照计算
            model.traverse(function(child) {
                if (child.isMesh) {
                    child.castShadow = false;
                    child.receiveShadow = false;
                    
                    // 减少材质复杂度
                    if (child.material) {
                        child.material.envMapIntensity = 0.5;
                    }
                }
            });
            
            // 让模型横向显示 - 旋转-90度（修正方向）
            model.rotation.x = -Math.PI / 2; // 绕X轴旋转-90度
        }
        
        // 更新加载进度显示
        function updateLoadingProgress() {
            const loadingText = document.querySelector('.loading-text');
            const progressBar = document.querySelector('.progress-bar');
            
            if (loadingText && totalChunksCount > 0) {
                // 计算块加载百分比
                const chunkPercent = Math.round((loadedChunksCount / totalChunksCount) * 100);
                
                // 计算文件大小加载百分比（如果有数据）
                let sizePercent = 0;
                if (totalBytesToLoad > 0) {
                    sizePercent = Math.round((totalBytesLoaded / totalBytesToLoad) * 100);
                }
                
                // 显示综合进度信息
                const speed = calculateLoadSpeed(totalBytesLoaded);
                const remainingTime = calculateRemainingTime();
                
                loadingText.textContent = `正在加载: ${loadedChunksCount}/${totalChunksCount} 块 (${chunkPercent}%)`;
                
                if (progressBar) {
                    // 使用文件大小百分比更准确地反映加载进度
                    const displayPercent = totalBytesToLoad > 0 ? sizePercent : chunkPercent;
                    progressBar.style.width = `${displayPercent}%`;
                    
                    // 根据进度改变进度条颜色
                    if (displayPercent >= 90) {
                        progressBar.style.backgroundColor = '#4CAF50';
                    } else if (displayPercent >= 50) {
                        progressBar.style.backgroundColor = '#FFC107';
                    } else {
                        progressBar.style.backgroundColor = '#2196F3';
                    }
                }
            }
        }
        
        // 所有分块加载完成后的处理
        function onAllChunksLoaded() {
            // 标记加载完成
            isLoadingComplete = true;
            
            // 检查是否有失败的块需要重试
            if (failedChunks.length > 0 && maxConcurrentChunkLoads > 0) {
                const retryMsg = `有 ${failedChunks.length} 个块加载失败，准备重试`;
                console.log(retryMsg);
                addLoadingLog(retryMsg);
                
                // 将失败的块重新添加到队列中
                chunkLoadingQueue = [...failedChunks, ...chunkLoadingQueue];
                failedChunks = [];
                
                // 继续加载
                loadNextChunks();
                return;
            }
            
            const completeMsg = '分块模型加载完成';
            console.log(completeMsg);
            addLoadingLog(completeMsg);
            
            // 获取成功加载的块数量
            const successfullyLoadedCount = Object.values(modelChunks).filter(chunk => chunk.loaded).length;
            const loadSummary = `成功加载 ${successfullyLoadedCount}/${totalChunksCount} 个模型块`;
            console.log(loadSummary);
            addLoadingLog(loadSummary);
            
            // 更新加载完成信息
            const loadingText = document.querySelector('.loading-text');
            const loadingDetails = document.querySelector('.loading-details');
            const progressBar = document.querySelector('.progress-bar');
            
            if (loadingText) {
                loadingText.textContent = '模型加载完成，正在准备场景...';
            }
            
            if (progressBar) {
                progressBar.style.width = '100%';
                progressBar.style.backgroundColor = '#4CAF50';
            }
            
            // 如果加载成功率低于50%，显示错误并创建替代几何体
            if (successfullyLoadedCount / totalChunksCount < 0.5) {
                const errorMsg = '模型分块加载失败率过高';
                console.error(errorMsg);
                addLoadingLog(errorMsg, true);
                
                if (loadingText) {
                    loadingText.textContent = `模型加载失败率过高，仅成功加载 ${successfullyLoadedCount}/${totalChunksCount} 个块`;
                    loadingText.style.color = '#ff0000';
                }
                
                // 显示错误后隐藏加载动画
                setTimeout(() => {
                    const loadingContainer = document.getElementById('loading-container');
                    if (loadingContainer) {
                        loadingContainer.classList.add('hidden');
                    }
                    // 创建替代几何体
                    createFallbackGeometry();
                }, 3000);
                return;
            }
            
            // 获取完整模型
            const fullModel = loadedModels.find(model => model.name === 'FullModel');
            
            if (fullModel) {
                // 调整相机以适应完整模型
                adjustCamera(fullModel);
                
                // 启动渐进式加载更新
                startProgressiveLoadingUpdate(fullModel);
            }
            
            // 计算总加载时间
            const totalLoadTime = Math.round((Date.now() - startTime) / 1000);
            const timeMsg = `总加载时间: ${totalLoadTime}秒 | 平均速度: ${formatFileSize(totalBytesLoaded / totalLoadTime)}/s`;
            console.log(timeMsg);
            addLoadingLog(timeMsg);
            
            if (loadingDetails) {
                loadingDetails.textContent = `场景准备就绪，点击任意位置开始体验 | ${timeMsg}`;
            }
            
            // 确保完全加载后再隐藏加载动画
            setTimeout(() => {
                const loadingContainer = document.getElementById('loading-container');
                if (loadingContainer) {
                    loadingContainer.classList.add('hidden');
                }
            }, 2000);
        }
        
        // 添加加载日志
        function addLoadingLog(message, isError = false) {
            const logsElement = document.getElementById('loading-logs');
            if (!logsElement) return;
            
            const logItem = document.createElement('div');
            logItem.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            if (isError) {
                logItem.style.color = '#ff6b6b';
            }
            logsElement.appendChild(logItem);
            logsElement.scrollTop = logsElement.scrollHeight;
        }
        
        // 显示/隐藏加载日志
        function setupLogsToggle() {
            const btn = document.getElementById('show-logs-btn');
            const logs = document.getElementById('loading-logs');
            
            if (btn && logs) {
                btn.addEventListener('click', () => {
                    logs.style.display = logs.style.display === 'none' || logs.style.display === '' ? 'block' : 'none';
                    btn.textContent = logs.style.display === 'block' ? '隐藏加载日志' : '显示加载日志';
                });
            }
        }
        
        // 设置缩放控制按钮
        function setupZoomControls() {
            const zoomInBtn = document.getElementById('zoom-in-btn');
            const zoomOutBtn = document.getElementById('zoom-out-btn');
            
            if (zoomInBtn && zoomOutBtn && controls) {
                // 放大按钮事件
                zoomInBtn.addEventListener('click', () => {
                    const zoomFactor = 1.2; // 放大因子
                    const newTargetDistance = camera.position.distanceTo(controls.target) / zoomFactor;
                    
                    // 计算新的相机位置（沿相机指向目标的方向移动）
                    const direction = new THREE.Vector3();
                    camera.getWorldDirection(direction);
                    camera.position.add(direction.clone().multiplyScalar(-camera.position.distanceTo(controls.target) + newTargetDistance));
                    
                    // 更新相机的近平面和远平面
                    camera.updateProjectionMatrix();
                });
                
                // 缩小按钮事件
                zoomOutBtn.addEventListener('click', () => {
                    const zoomFactor = 1.2; // 缩小因子
                    const newTargetDistance = camera.position.distanceTo(controls.target) * zoomFactor;
                    
                    // 计算新的相机位置（沿相机指向目标的反方向移动）
                    const direction = new THREE.Vector3();
                    camera.getWorldDirection(direction);
                    camera.position.add(direction.clone().multiplyScalar(-camera.position.distanceTo(controls.target) + newTargetDistance));
                    
                    // 更新相机的近平面和远平面
                    camera.updateProjectionMatrix();
                });
            }
        }
        
        // 初始化应用
        function initApp() {
            // 设置日志切换
            setupLogsToggle();
            
            // 改进的加载动画处理逻辑
            const loadingContainer = document.getElementById('loading-container');
            
            // 确保加载动画元素存在
            if (!loadingContainer) {
                console.error('未找到加载容器元素');
                return;
            }
            
            // 记录开始加载时间
            startTime = Date.now();
            lastLoadedTime = startTime;
            
            try {
                addLoadingLog('开始初始化应用');
                initThreeJS();
                scanModelFiles();
                
                // 设置缩放控制按钮
                setupZoomControls();
                
                // 设置加载提示5秒后平滑消失
                const loadingTip = document.getElementById('loading-tip');
                if (loadingTip) {
                    setTimeout(() => {
                        loadingTip.classList.add('hidden');
                    }, 5000);
                }
                
                // 注意：现在modelFiles可能为空，因为分块加载通过loadPreChunkedModel函数处理
                // 所以我们不再在这里加载模型，而是由checkForChunksDirectory和loadPreChunkedModel函数处理
                
            } catch (error) {
                const errorMsg = `应用初始化失败: ${error.message}`;
                console.error(errorMsg);
                addLoadingLog(errorMsg, true);
                
                // 发生错误时显示错误信息
                const loadingText = document.querySelector('.loading-text');
                if (loadingText) {
                    loadingText.textContent = '加载失败，请刷新页面重试';
                    loadingText.style.color = '#ff0000';
                }
                
                // 5秒后隐藏加载动画
                setTimeout(() => {
                    loadingContainer.classList.add('hidden');
                }, 5000);
            }
        }
        
        // 当页面加载完成后初始化应用
        window.addEventListener('load', initApp);
    </script>
</body>
</html>